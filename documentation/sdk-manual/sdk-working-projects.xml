<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"
[<!ENTITY % poky SYSTEM "../poky.ent"> %poky; ] >

<chapter id='sdk-working-projects'>

    <title>Using the SDK Toolchain Directly</title>

    <para>
        You can use the SDK toolchain directly with Makefile,
        Autotools, and <trademark class='trade'>Eclipse</trademark>-based
        projects.
        This chapter covers the first two, while the
        "<link linkend='sdk-eclipse-project'>Developing Applications Using <trademark class='trade'>Eclipse</trademark></link>"
        Chapter covers the latter.
    </para>

    <section id='autotools-based-projects'>
        <title>Autotools-Based Projects</title>

        <para>
            Once you have a suitable
            <ulink url='&YOCTO_DOCS_REF_URL;#cross-development-toolchain'>cross-development toolchain</ulink>
            installed, it is very easy to develop a project using the
            <ulink url='https://en.wikipedia.org/wiki/GNU_Build_System'>GNU Autotools-based</ulink>
            workflow, which is outside of the
            <ulink url='&YOCTO_DOCS_REF_URL;#build-system-term'>OpenEmbedded build system</ulink>.
        </para>

        <para>
            The following figure presents a simple Autotools workflow.
            <imagedata fileref="figures/sdk-autotools-flow.png" width="7in" height="8in" align="center" />
        </para>

        <para>
            Follow these steps to create a simple Autotools-based
            "Hello World" project:
            <note>
                For more information on the GNU Autotools workflow,
                see the same example on the
                <ulink url='https://developer.gnome.org/anjuta-build-tutorial/stable/create-autotools.html.en'>GNOME Developer</ulink>
                site.
            </note>
            <orderedlist>
                <listitem><para>
                    <emphasis>Create a Working Directory and Populate It:</emphasis>
                    Create a clean directory for your project and then make
                    that directory your working location.
                    <literallayout class='monospaced'>
     $ mkdir $HOME/helloworld
     $ cd $HOME/helloworld
                    </literallayout>
                    After setting up the directory, populate it with three
                    simple files needed for the flow.
                    You need a project source file, a file to help with
                    configuration, and a file to help create the Makefile:
                    <filename>hello.c</filename>,
                    <filename>configure.ac</filename>, and
                    <filename>Makefile.am</filename>, respectively:
                    <itemizedlist>
                        <listitem><para>
                            <emphasis><filename>hello.c</filename>:</emphasis>
                            <literallayout class='monospaced'>
     #include &lt;stdio.h&gt;

     main()
        {
           printf("Hello World!\n");
        }
                            </literallayout>
                            </para></listitem>
                        <listitem><para>
                            <emphasis><filename>configure.ac</filename>:</emphasis>
                            <literallayout class='monospaced'>
     AC_INIT(hello,0.1)
     AM_INIT_AUTOMAKE([foreign])
     AC_PROG_CC
     AC_CONFIG_FILES(Makefile)
     AC_OUTPUT
                            </literallayout>
                            </para></listitem>
                        <listitem><para>
                            <emphasis><filename>Makefile.am</filename>:</emphasis>
                            <literallayout class='monospaced'>
     bin_PROGRAMS = hello
     hello_SOURCES = hello.c
                            </literallayout>
                            </para></listitem>
                    </itemizedlist>
                    </para></listitem>
                <listitem><para>
                    <emphasis>Source the Cross-Toolchain
                    Environment Setup File:</emphasis>
                    As described earlier in the manual, installing the
                    cross-toolchain creates a cross-toolchain
                    environment setup script in the directory that the SDK
                    was installed.
                    Before you can use the tools to develop your project,
                    you must source this setup script.
                    The script begins with the string "environment-setup"
                    and contains the machine architecture, which is
                    followed by the string "poky-linux".
                    For this example, the command sources a script from the
                    default SDK installation directory that uses the
                    32-bit Intel x86 Architecture and the
                    &DISTRO_NAME; Yocto Project release:
                    <literallayout class='monospaced'>
     $ source /opt/poky/&DISTRO;/environment-setup-i586-poky-linux
                    </literallayout>
                    </para></listitem>
                <listitem><para>
                    <emphasis>Generate the Local <filename>aclocal.m4</filename> Files:</emphasis>
                    The following command generates the local
                    <filename>aclocal.m4</filename> files, which are used
                    later with the <filename>autoconf</filename> command:
                    <literallayout class='monospaced'>
     $ aclocal
                    </literallayout>
                    </para></listitem>
                <listitem><para>
                    <emphasis>Create the <filename>configure</filename> Script:</emphasis>
                    The following command creates the
                    <filename>configure</filename> script:
                    <literallayout class='monospaced'>
     $ autoconf
                    </literallayout>
                    </para></listitem>
                <listitem><para>
                    <emphasis>Generate Files Needed by GNU Coding
                    Standards:</emphasis>
                    GNU coding standards require certain files in order
                    for the project to be compliant.
                    This command creates those files:
                    <literallayout class='monospaced'>
     $ touch NEWS README AUTHORS ChangeLog
                    </literallayout>
                    </para></listitem>
                <listitem><para>
                    <emphasis>Generate the <filename>Makefile.in</filename> File:</emphasis>
                    This command generates the
                    <filename>Makefile.in</filename>, which is used later
                    during cross-compilation:
                    <literallayout class='monospaced'>
     $ automake -a
                    </literallayout>
                    </para></listitem>
                <listitem><para>
                    <emphasis>Cross-Compile the Project:</emphasis>
                    This command compiles the project using the
                    cross-compiler.
                    The
                    <ulink url='&YOCTO_DOCS_REF_URL;#var-CONFIGURE_FLAGS'><filename>CONFIGURE_FLAGS</filename></ulink>
                    environment variable provides the minimal arguments for
                    GNU configure:
                    <literallayout class='monospaced'>
     $ ./configure ${CONFIGURE_FLAGS}
                    </literallayout>
                    For an Autotools-based project, you can use the
                    cross-toolchain by just passing the appropriate host
                    option to <filename>configure.sh</filename>.
                    The host option you use is derived from the name of the
                    environment setup script found in the directory in which you
                    installed the cross-toolchain.
                    For example, the host option for an ARM-based target that uses
                    the GNU EABI is
                    <filename>armv5te-poky-linux-gnueabi</filename>.
                    You will notice that the name of the script is
                    <filename>environment-setup-armv5te-poky-linux-gnueabi</filename>.
                    Thus, the following command works to update your project
                    and rebuild it using the appropriate cross-toolchain tools:
                    <literallayout class='monospaced'>
     $ ./configure --host=armv5te-poky-linux-gnueabi \
        --with-libtool-sysroot=<replaceable>sysroot_dir</replaceable>
                    </literallayout>
                    <note>
                        If the <filename>configure</filename> script results in
                        problems recognizing the
                        <filename>--with-libtool-sysroot=</filename><replaceable>sysroot-dir</replaceable>
                        option, regenerate the script to enable the support by
                        doing the following and then run the script again:
                        <literallayout class='monospaced'>
     $ libtoolize --automake
     $ aclocal -I ${OECORE_TARGET_SYSROOT}/usr/share/aclocal [-I <replaceable>dir_containing_your_project-specific_m4_macros</replaceable>]
     $ autoconf
     $ autoheader
     $ automake -a
                        </literallayout>
                    </note>
                    </para></listitem>
                <listitem><para>
                    <emphasis>Make and Install the Project:</emphasis>
                    These two commands generate and install the project
                    into the destination directory:
                    <literallayout class='monospaced'>
     $ make
     $ make install DESTDIR=./tmp
                    </literallayout>
                    <note>
                        To learn about environment variables established
                        when you run the cross-toolchain environment setup
                        script and how they are used or overridden when
                        the Makefile, see the
                        "<link linkend='makefile-based-projects'>Makefile-Based Projects</link>"
                        section.
                    </note>
                    This next command is a simple way to verify the
                    installation of your project.
                    Running the command prints the architecture on which
                    the binary file can run.
                    This architecture should be the same architecture that
                    the installed cross-toolchain supports.
                    <literallayout class='monospaced'>
     $ file ./tmp/usr/local/bin/hello
                    </literallayout>
                    </para></listitem>
                <listitem><para>
                    <emphasis>Execute Your Project:</emphasis>
                    To execute the project in the shell, simply enter
                    the name.
                    You could also copy the binary to the actual target
                    hardware and run the project there as well:
                    <literallayout class='monospaced'>
     $ ./hello
                    </literallayout>
                    As expected, the project displays the "Hello World!"
                    message.
                    </para></listitem>
            </orderedlist>
        </para>
    </section>

    <section id='makefile-based-projects'>
        <title>Makefile-Based Projects</title>

        <para>
            Simple Makefile-based projects use and interact with the
            cross-toolchain environment variables established when you run
            the cross-toolchain environment setup script.
            The environment variables are subject to general
            <filename>make</filename> rules.
        </para>

        <para>
            This section presents a simple Makefile development flow and
            provides an example that lets you see how you can use
            cross-toolchain environment variables to replace or override
            variables used in your Makefile.
            <imagedata fileref="figures/sdk-makefile-flow.png" width="6in" height="7in" align="center" />
        </para>

        <para>
            The main point of this section is to explain the following three
            cases regarding variable behavior:
            <itemizedlist>
                <listitem><para>
                    <emphasis>Case 1 - No Variables Set in the
                    <filename>Makefile</filename> that Map to Equivalent
                    Environment Variables Set in the SDK Setup Script:</emphasis>
                    Because matching variables are not specifically set in the
                    <filename>Makefile</filename>, the variables retain their
                    values based on the environment setup script.
                    </para></listitem>
                <listitem><para>
                    <emphasis>Case 2 - Variables Are Set in the Makefile that
                    Map to Equivalent Environment Variables from the SDK
                    Setup Script:</emphasis>
                    Specifically setting matching variables in the
                    <filename>Makefile</filename> during the build results in
                    the environment settings of the variables being
                    overwritten.
                    In this case, the variables you set in the
                    <filename>Makefile</filename> are used.
                    </para></listitem>
                <listitem><para>
                    <emphasis>Case 3 - Variables Are Set Using the Command Line
                    that Map to Equivalent Environment Variables from the
                    SDK Setup Script:</emphasis>
                    Executing the <filename>Makefile</filename> from the
                    command line results in the environment settings of the
                    variables being overwritten.
                    In this case, the command-line content is used.
                    <note>
                        The one exception to this is if you use the following
                        command-line option:
                        <literallayout class='monospaced'>
     $ make -e <replaceable>target</replaceable>
                        </literallayout>
                        Using the "-e" option with <filename>make</filename>
                        causes the environment variables to be used during
                        the build.
                    </note>
                    </para></listitem>
            </itemizedlist>
        </para>

        <para>
            The remainder of this section presents a simple Makefile example
            that demonstrates these variable behaviors.
        </para>

        <para>
            In a new shell environment variables are not established for the
            SDK until you run the setup script.
            For example, the following commands show null values for four
            variables that are set when you run the SDK environment setup
            script for a 64-bit build host and an i586-tuned target
            architecture for a <filename>core-image-sato</filename> image
            using the current &DISTRO; Yocto Project release:
            <literallayout class='monospaced'>
     $ echo ${CC}

     $ echo ${LD}

     $ echo ${CFLAGS}

     $ echo ${CXXFLAGS}
            </literallayout>
            Running the setup script and then echoing the variables shows the
            values established for the SDK:
            <literallayout class='monospaced'>
     $ source /opt/poky/2.5/environment-setup-i586-poky-linux
     $ echo ${CC}
     i586-poky-linux-gcc -m32 -march=i586 --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux
     $ echo ${LD}
     i586-poky-linux-ld --sysroot=/opt/poky/2.5/sysroots/i586-poky-linux
     $ echo ${CFLAGS}
     -O2 -pipe -g -feliminate-unused-debug-types
     $ echo ${CXXFLAGS}
     -O2 -pipe -g -feliminate-unused-debug-types
            </literallayout>
        </para>

        <para role='writernotes'>
            NEED REST OF THE EXAMPLE.
            WORKING ON GETTING IT TO WORK PROPERLY.
        </para>

<!--
To illustrate this, consider the following four cross-toolchain
            environment variables:
            <literallayout class='monospaced'>
     <ulink url='&YOCTO_DOCS_REF_URL;#var-CC'>CC</ulink>="i586-poky-linux-gcc -m32 -march=i586 &DASH;&DASH;sysroot=/opt/poky/&DISTRO;/sysroots/i586-poky-linux"
     <ulink url='&YOCTO_DOCS_REF_URL;#var-LD'>LD</ulink>="i586-poky-linux-ld &DASH;&DASH;sysroot=/opt/poky/&DISTRO;/sysroots/i586-poky-linux"
     <ulink url='&YOCTO_DOCS_REF_URL;#var-CFLAGS'>CFLAGS</ulink>="-O2 -pipe -g -feliminate-unused-debug-types"
     <ulink url='&YOCTO_DOCS_REF_URL;#var-CXXFLAGS'>CXXFLAGS</ulink>="-O2 -pipe -g -feliminate-unused-debug-types"
            </literallayout>
            Now, consider the following three cases:
            <note>
                For information on the variables set up by the cross-toolchain
                environment setup script, see the
                "<link linkend='sdk-running-the-extensible-sdk-environment-setup-script'>Running the Extensible SDK Environment Setup Script</link>"
                section.
            </note>
        </para>
-->
    </section>
</chapter>
<!--
vim: expandtab tw=80 ts=4
-->
